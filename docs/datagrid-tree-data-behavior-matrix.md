# DataGrid TreeData Behavior Matrix (Baseline Contract)

Updated: `2026-02-11`  
Status: `baseline locked`  
Scope: `@affino/datagrid-core` treeData semantics (core-first, framework-agnostic)

## Purpose

This document is the canonical target behavior contract for `treeData`.  
All implementation steps must preserve these semantics unless this file is explicitly revised.

## Core Data Contract

1. Identity:
   - Every leaf row must have a stable `rowId`.
   - Index-based identity is forbidden in tree mode.
2. Hierarchy source:
   - Exactly one source is active:
     - path mode (`getDataPath(row)`), or
     - parent mode (`getParentId(row)`).
   - Mixing both in one model instance is invalid.
3. Node kinds:
   - `leaf`: real data row.
   - `group`: synthetic tree node generated by tree projection.
4. Expansion state:
   - Stored as deterministic snapshot keyed by stable group identity.
   - Must survive projection refresh when identity is unchanged.

## Canonical Group Identity

1. Path mode:
   - `groupKey = "tree:path:" + JSON.stringify(normalizedSegments)`.
   - `normalizedSegments` are trimmed, non-empty string segments from `getDataPath`.
2. Parent mode:
   - `groupKey = "tree:parent:" + String(rowId)`.
   - Parent group node represents the parent data row identity.
3. Group identity is canonical and must not be changed by runtime refresh.

## Invalid Data Policy

1. Orphans:
   - Default: keep row as top-level leaf and emit deterministic diagnostics.
2. Cycles:
   - Must not break projection.
   - Cycle edges are ignored deterministically, with diagnostics.
3. Duplicate rowId:
   - Client row model:
     - hard contract violation,
     - reject update and keep previous valid snapshot/revision.
   - Server/data-source row model:
     - duplicate handling is delegated to upstream data contract,
     - row model forwards diagnostics context but does not silently rewrite identity.

## Projection Semantics

1. Pipeline:
   - `source rows -> tree index -> filter markers -> sibling sort -> flatten(expansion, filterPolicy) -> viewport`.
   - Filter stage marks match-state; tree index is built from valid source rows first.
   - Sibling sort is applied on sibling sets before flattening (deterministic tie-break by `rowId`).
2. Flattening:
   - Collapsed node hides descendants from visible projection.
   - Expanded node includes descendants preserving sibling order semantics.
3. Group identity:
   - Group node key must be stable across no-op refresh.

## Filter Semantics (Tree Mode)

Supported policies:
1. `leaf-only`: only matching leaf rows are shown as flat rows (no synthetic groups, no ancestor chain, level reset to `0`).
2. `include-parents`: matched leaves + required ancestor chain are shown.
3. `include-descendants`: matched node keeps full descendant subtree visible.

Rules:
- Policy must be explicit in treeData configuration.
- Default policy: `include-parents`.

## Sort Semantics (Tree Mode)

1. Sort applies within sibling sets.
2. Parent-child relationship is never broken by sort.
3. Tie-breaker fallback is stable `rowId`.

## Selection Semantics (Tree Mode)

1. Anchor/focus/range operate on flattened visible rows.
2. Group selection policy is explicit:
   - default `groupSelectsChildren = false`.
3. Collapsed descendants are not implicitly selected unless policy says so.

## API/State Semantics

1. Expansion API:
   - `expand`, `collapse`, `toggle`, `expandAll`, `collapseAll`.
2. Snapshot roundtrip:
   - Importing exported expansion snapshot must restore the same visible projection (for equal source rows + config).
3. Determinism:
   - Repeated no-op refresh returns equivalent projection snapshot.

## Diagnostics Contract

Tree-mode diagnostics must be deterministic and coalesced.

Minimum canonical snapshot shape:
- `treeDataDiagnostics.orphans`
- `treeDataDiagnostics.cycles`
- `treeDataDiagnostics.duplicates`
- `treeDataDiagnostics.lastError`

Event-mode adapters may emit diagnostic events, but must coalesce by deterministic key.

## DataSource Tree Expansion Pull Contract

When using data-source backed row model in tree mode:
1. Every tree expansion/config pull must include `treeData` context:
   - `operation` (`set-group-by`, `set-group-expansion`, `toggle-group`, `expand-group`, `collapse-group`, `expand-all-groups`, `collapse-all-groups`)
   - `scope` (`branch` or `all`)
   - `groupKeys` (normalized unique target keys)
2. Backpressure rules remain identical to non-tree pulls:
   - higher-priority pulls can preempt lower-priority pulls,
   - equal requests can coalesce,
   - deferred requests must preserve tree context.
3. Server-backed row model semantics:
   - `groupBy`/`groupExpansion` are forwarded as query semantics.
   - Server-backed row model does not synthesize client-side group rows by itself.
   - `getRowsInRange` currently returns compact loaded rows (not fixed-length with holes); renderer must key by row identity/indices.

## Performance/Invalidation Baseline

1. Tree row invalidations are row-axis scoped.
2. Tree projection updates must not force unnecessary horizontal-layout recompute.
3. Deep tree expand/collapse must be bench-covered before final closure.

## Verification Mapping

- Contract tests:
  - `treeData` config validation
  - projection determinism
  - expansion snapshot roundtrip
  - filter/sort/selection policy matrix
- Integration tests:
  - viewport invalidation scope in tree mode
- Performance:
  - stress runs on deep hierarchy and burst expand/collapse
